---
layout: post
title: "The Unreliability of MD5-based OTPs"
---

As documented in the OTP [key URI format specification](https://code.google.com/p/google-authenticator/wiki/KeyUriFormat#Algorithm), OTP generators are expected to support the use of four algorithms when computing an HMAC value: SHA-1, SHA-256, SHA-512, and MD5. The [TOTP RFC](https://tools.ietf.org/html/rfc6238#section-1.2) states that any of the three above-mentioned SHAs may be used, and the [HOTP RFC](https://tools.ietf.org/html/rfc4226#section-5.2) methions only SHA-1. While not explicitly mentioned in the definitions of the HOTP and TOTP algorithms, MD5 is just another hash function like the SHAs, and seems like a valid alternative when generating a one-time password. However, because of the comparatively short length of the hash produced by MD5, it is not a valid option for use in the HOTP algorithm.

As described in [RFC 4226](https://tools.ietf.org/html/rfc4226#section-5.3), the HOTP algorithm first computes a hash from the secret and counter values, and then extracts a four-byte segment of the hash value to use as the basis for the password. The choice of *which* four bytes to extract is made by casting the last four bits of the hash as an integer and using that integer value as an offset into the hash. Starting at this offset, the next four bytes are read from the hash and used in further computation to produce the password.

Because the offset integer is specified by only four bits, it must be one of the integer values that can be represented in four bits, in the range \[0, 15\]. This is a problem when the hash function used is MD5, because the length of its hash is 16 bytes. If the offset integer is 13 or greater, the four bytes extracted will extend beyond the end of the hash, reading from memory not produced by the hash function.

## An Example

Consider the OTP token represented by this URL:

    otpauth://hotp/MD5?algorithm=MD5&secret=AEAAAAA&counter=1

The hash value is computed as follows:

    secret = <01000000>
    counter = <00000000 00000001>
    hash = HMAC-MD5(secret, counter)

The hash value produced is:

    <650c4bfb 740d273d 51d51866 a874b2ae>

When broken down by byte [as is done in the RFC](https://tools.ietf.org/html/rfc4226#section-5.4):

    Byte Number  00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
                -------------------------------------------------
    Hash Value   65 0c 4b fb 74 0d 27 3d 51 d5 18 66 a8 74 b2 ae 

The last four bits of the hash are represented by the final hexidecimal character ("`e`") and produce an offset value of 14. As is clear from the byte table above, selecting four bytes from the 16-byte hash starting at byte 14 would overrun the end of the hash, producing a truncated value of <pre>b2 ae ?? ??</pre> where the "`?`" characters represent nondeterministic and invalid bits.
